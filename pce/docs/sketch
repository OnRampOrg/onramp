PLANNING -----------------------------------------------------------------------
Brainstorming:
- how PCE modules work together
- onramp_pce_service.py
- onramp_pce_setup.py
- state objects
	- locking
- modules
- jobs
- schedulers
	- structure of scheduler
	- adding a new scheduler
- dispatchers
	- each class
- Service launching

Current section plan (in no particular order, * means drafted):
- onramp_pce_setup.py
- onramp_pce_service.py
* PCE HTTP/JSON Interface
* PCE Configuration
* PCE.tools Module
* PCE.jobs Module
* PCE.schedulers Module
- Working with Job and Module State
- Notes on the Execution of bin/onramp_*.py Scripts (logging, etc.)
- Requirements
- Something about launching potentially long-running processes in forked processes.

COPY ---------------------------------------------------------------------------

**Note: To avoid confusion, the convention is taken in this documentation that 'module' is a reference to an OnRamp educational module, while a Python module will be referred to by the phrase, 'Python module'.

PCE Configuration

User-level configuration of the PCE service exists in the onramp/pce/onramp_pce_config.ini file. The file contains two sections: server and cluster. The following paramaters are used:

[server]
socket_host = IP address
socket_port = Port

[cluster]
batch_scheduler = One of: SLURM, PBS, SGE
log_level = One of: DEBUG, INFO, WARN, ERROR, CRITICAL
log_file = Absolute or relative to onramp/pce


PCE HTTP/JSON Interface

The PCE servivce is made available via the CherryPy web server. The server is contolled via onramp/pce/onramp_pce_service.py commands. Start, stop, and restart are available. When started, onramp/pce/src/RESTservice.py is launched. This script is responsible for initializing the CherryPy web server instance; loading pce configuration from onramp/pce/onramp_pce_config.ini; initializing the service's logger; registering stop and restart signal handlers; tracking the PID of the service via the PIDFile CherryPy plugin; and mapping URL endpoints to HTTP method dispatchers.

The method dispatchers made available to the service live in PCE.dispatchers. This package is the only place in the PCE library where CherryPy-specific code should exist. CherryPy is configured for method dispatching, thus, dispatchers are simply classes that define one or more of GET, POST, PUT, DELETE as functions. The defined functions are then called when a request is made to the corresponding method to the URL the dispatcher is mapped to. The _OnRampDispatcher base class is defined here. This class handles things that most of the PCE dispatchers will need: JSON i/o, logging, and access to the defined logger.

Dispatchers should simply accept requests, parse the request parameters, validate them, use them to make calls to external packages, and return the results. All HTTP errors and request parameter format errors should be caught in a dispatcher. THe PCE service uses the configobj library to acheive this. Specification files for all requests that accept JSON parameters are defined in onramp/pce/src/configspecs. These files are used in conjunction with the configobj library to validate received JSON request dictionaries.


PCE.tools Package

The PCE.tools package contains the Python modules, classes, and functions for administering OnRamp educational modules and jobs. The package is broken into the modules, jobs, and schedulers python modules, and also contains support functions for tracking and requesting output files generated by modules.

PCE.tools.modules

This Python module contains a class for working with module state (documented in the section, Working with Module and Job State) and the following:

For working with module sources:
The PCE service was designed to allow installation of modules from various sources, such as, the local filesystem, git repositories, tarballs, etc. The supported types are mapped to functions that handle them in the source_handlers dictionary. Currently, only the local filesystem is supported as a module source. It is mapped to the _local_checkout() function under the key 'local'. A list of supported source types is returned by get_source_types().

For administering modules:
Modules can be installed from supported sources via the install_module() function. This function checks the module out from the given source, creates a local copy under the given parent folder with the given id and name and creates folders needed by the PCE service. Upon success or failure, the state of the module is stored using the ModState class. The deploy_module() function executes the module's deploy script, logs any output, and updates the module's state as required. The init_module_delete() function is used to trigger deletion of a module. In the current version of the PCE, modules may exist in states that cannot allow immediate deletion (mostly when bin/onramp_*.py scripts are executing), thus, this function does not perform any of actions needed for deletion. These are accomplished by the call to _delete_module(). If the module is in an acceptable delete state when init_module_delete() is called, then _delete_module() is immediately called. If not, the module's state is flagged for deletion when the module reaches an acceptable delete state. For this reason, all transitions of module state from an unacceptable delete state to an acceptable one must check the module's state and call _delete_module() if the state is flagged for deletion.

For viewing modules on the system:
The get_modules() function returns a list of modules available on the system, or a single module if given the module id. Prior to returning, each module is passed through the _clean_mod() function to remove any private state attrs present. Private state attrs are denoted by an underscore prefix. OnRamp ships with several example modules. These modules aren't checked out to the PCE service by default, but may be checked out by the system administrator. The get_available_modules() function returns a list of these modules.

functions:
*get_source_types
*_local_checkout
*install_module
*deploy_module
*_clean_mod
*get_modules
*get_available_modules
*init_module_delete
*_delete_module

Attrs:
*source_handlers


PCE.tools.jobs

This Python module contains a class for working with job state (documented in the section, Working with Module and Job State) and the following:

For administering jobs:
The launch_job() function initiates the launch of a parallel job using the given module and paramaters. Job state is initialized, the given module is checked for valid state, required directory structure is created, and given run parameters are verified against the modules config/onramp_uioptions.spec file using the configobj library. If all is well, bin/onramp_preprocess.py is executed and its output (good or bad) is logged. A scheduler instance is then obtained for the scheduler that matches the config in onramp/pce/onramp_pce_config.ini and used to schedule the job. The init_job_delete() function is used to trigger deletion of a job. In the current version of the PCE, jobs may exist in states that cannot allow immediate deletion (mostly when bin/onramp_*.py scripts are executing), thus, this function does not perform any of actions needed for deletion. These are accomplished by the call to _delete_job(). If the job is in an acceptable delete state when init_job_delete() is called, then _delete_job() is immediately called. If not, the job's state is flagged for deletion when the job reaches an acceptable delete state. For this reason, all transitions of job state from an unacceptable delete state to an acceptable one must check the job's state and call _delete_job() if the state is flagged for deletion.

For viewing jobs on the system:
The get_jobs() function returns a list of jobs available on the system, or a single job if given the job id. The function calls the _build_job() function, which updates state and currates job results as required prior to returning the job. Here, job state is checked and, if appropriate, a scheduler instance returns the state of the job as maintained by the system's scheduler. Depending on this state, _get_module_status_output() may be called to launch bin/onramp_status.py or _job_postprocess() may be called to initiate postprocessing (and subsequently call and log output from bin/onramp_postprocess.py). After these actions are launched and the job's state (as maintained by the PCE, not the system scheduler) is updated, _build_job() returns the job back to get_jobs(). Prior to returning from get_jobs(), each job is passed through the _clean_job() function to remove any private state attrs present. Private state attrs are denoted by an underscore prefix.

functions:
*launch_job
*_job_postprocess
*_get_module_status_output
*_build_job
*_clean_job
*get_jobs
*init_job_delete
*_delete_job


Working with Module and Job State

Module and Job state are accessed, updated, and stored using the ModState and JobState classes given in PCE.tools.modules and PCE.tools.jobs. These classes inherit from Python dictionaries, and state attrs are accessed/stored as key/value pairs of an instance. For example, to update the state of a job tracked by the instance job1:

job1['state'] = 'New state'

Behind the scenes, state must be stored and should also be prevented from being accessed concurrently. For these reasons, ModState and JobState instances should only be accessed in conjunction with Python's with keyword. For example:

with JobState(1) as job1:
    job1['state'] = 'New state'

Using the state classes in this manner will ensure that state files are opened/closed and state locks are acquired/released when appropriate. Note that due to the locking requirement, instantiating a state object may block if a lock is held somewhere else until it is released. To prevent deadlock when both job and module state is needed, always nest the instantiation of module state in the with block that instantiates job state. More simply, acquire job state prior to acquiring module state. For example:

with JobState(1) as job_state:
    with ModState(27) as mod_state:
        job_state['mod_id'] = mod_state['id']

Simultaneous access to multiple JobState instances or to multiple ModState instances should not be a requirement, and thus, should be avoided. In the event that it is not avoided, a similar convention will be required to prevent deadlock (lower id first maybe?).

Locking of state instances is currently accomplished by locking their underlying state files and keeping them open for the duration of the instances' lives.


PCE.schedulers Module

This module provides a base class for scheduler classes to be derived from, scheduler classes for supported batch schedulers, and a generic constructor which returns and instance of the proper scheduler class given the type.

Adding a new scheduler:
To add a new scheduler, derive from the _BatchScheduler base class, and define the following methods:

is_scheduler_for(cls, type): This must be a class method, and should return True if the class supports the scheduler given by type, which is a string, and False if not. The type string should be the string given to the onramp/pce/onramp_pce_config.ini scheduler paramater.

get_batch_script(self, run_name, numtasks=, email=): This returns a batch script formatted for the scheduler the class is supporting.

schedule(self, proj_loc): This method performs that action of scheduling the job given by os.path.join(proj_loc, 'script.sh'). It should return the following dictionary:
{
    'status_code': Non-zero int to indicate the failure,
    'status_msg': Message giving details about result,
    'job_num': Job number given by scheduler. Field is only present on success
}

check_status(self, scheduler_job_num): Return indication of status for job given by scheduler_job_num. Return value is the following tuple:
(
    0 for success|-1 for status check failure or job failure|-2 for unexpected result from scheduler,
    Running|Queued|Done|error-message as appropriate
)

cancel_job(self, scheduler_job_num): Commands the scheduler to cancel the job given by scheduler_job_num. Returns the following tupld:
(
    0 for success|-1 for failure,
    Message giving details about result
)

Instantiating a scheduler:
The constructor Scheduler(type) should be used to instantiate a scheduler of the given type, where type is the string checked by the is_scheduler_for classmethod for the desired scheduler class.

classes:
*_BatchScheduler

functions:
*Scheduler()
